# 1.0.6
- D同学在雪地之后还会经过一段草地
这种情况下就算有多重继承也不好解决
解决方案：
1. 一般来说直接将A的代码改改就好了，反正A不会经过草地，ACar的代码也能正常运行。但是实际上D的需求对A需求有一定侵入性，这样很可能会导致后续的测试与维护出现问题；
2. 或者就把ACar状态的代码改为protected，再从ACar继承一个DCar，重载getWheels方法，但这样解决的话后续如果遇到更多奇葩的情况，那可能就需要维护非常多的类

# 1.0.5
- B同学则有不一样的需求，每天都会路过一段非常寒冷的地方，需要及时换引擎
- C同学则更惨，他首先需要路过一段雪地，然后要攀爬一段雪山，所以又要换轮胎，还要换引擎
1. 可以将一部分共通的代码封装起来，但是这样会产生新的耦合：一但A或者B的需求变更，都可能影响到C
2. 垃圾java和javascript没有多重继承，最新的一些scala或者rust都提供了多重继承的可能性

# 1.0.4
- A同学每天上下班（A面向过程的代码也需要在很多地方复用）都需要手动换很麻烦，于是他重新设计（**继承和重载**）了一辆车；

# 1.0.3
- A同学也想复用蟋蟀的车，但是他上班的地方中间有一段雪地，普通轮胎无法过去，所以需要在路过的时候动态的换成带有铁链的轮胎。
使用了**setter**函数来动态的注入依赖

# 1.0.2
- 同学知道蟋蟀组装的车之后都希望蟋蟀也能为自己组装一台，不过每个同学都有自己的想法，比如测试同学想要用自己做的活塞组装并且测试一下
1. **依赖倒置原则**，之前蟋蟀自己组装的车直接依赖了自己的轮胎、活塞、引擎的实现。那想要复用车的代码，就需要将依赖的关系反过来，由需要复用的车来声明自己所需要的的部件需要的能力（**interface**）；
2. **注入依赖**，对于使用方，则相当于是将车所需要的依赖动态的注入到类的内部实现中，注入依赖的方式一般有三种，这一步骤中就是constructor这种
    1. constructor;
    2. setter;
    3. 接口动态注册;

# 1.0.1
- 蟋蟀为了自己上班组装了一台自己专用的车

# 1.0.0
- 项目配置